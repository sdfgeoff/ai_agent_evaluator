<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Go-Kart Racing</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="info">Use WASD or Arrow Keys to drive the kart.</div>
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script>
    // Scene, camera, renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5,10,7);
    scene.add(dirLight);

    // Ground (road)
    const roadWidth = 20;
    const roadLength = 1000;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(roadWidth, roadLength),
      new THREE.MeshLambertMaterial({ color: 0x333333 })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);
    
    // Road center stripes
    const stripeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    for (let i = -500; i < 500; i += 20) {
      const stripe = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 10),
        stripeMaterial
      );
      stripe.position.set(0, 0.01, i + 5);
      stripe.rotation.x = -Math.PI/2;
      scene.add(stripe);
    }

    // Kart model (simple)
    const kart = new THREE.Group();
    // Body
    const bodyGeom = new THREE.BoxGeometry(2, 0.5, 3);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
    const body = new THREE.Mesh(bodyGeom, bodyMat);
    body.position.y = 0.5;
    kart.add(body);
    // Wheels
    const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
    const wheelMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
    function makeWheel(x, z) {
      const wheel = new THREE.Mesh(wheelGeom, wheelMat);
      wheel.rotation.z = Math.PI/2;
      wheel.position.set(x, 0.2, z);
      kart.add(wheel);
    }
    makeWheel(-1, -1.2);
    makeWheel(1, -1.2);
    makeWheel(-1, 1.2);
    makeWheel(1, 1.2);
    
    scene.add(kart);

    // Controls state
    const keys = { ArrowUp: 0, ArrowDown: 0, ArrowLeft: 0, ArrowRight: 0, KeyW: 0, KeyS: 0, KeyA: 0, KeyD: 0 };
    document.addEventListener('keydown', e => { if (keys[e.code] !== undefined) keys[e.code] = 1; });
    document.addEventListener('keyup', e => { if (keys[e.code] !== undefined) keys[e.code] = 0; });

    let speed = 0;
    const maxSpeed = 1;
    const accel = 0.02;
    const brake = 0.04;
    const friction = 0.01;

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      // Input
      if (keys.ArrowUp || keys.KeyW) speed += accel;
      if (keys.ArrowDown || keys.KeyS) speed -= brake;
      // Clamp
      speed = Math.max(-maxSpeed, Math.min(maxSpeed, speed));
      // Friction
      if (! (keys.ArrowUp || keys.KeyW || keys.ArrowDown || keys.KeyS) ) {
        if (speed > 0) speed = Math.max(0, speed - friction);
        if (speed < 0) speed = Math.min(0, speed + friction);
      }
      // Steering
      if (keys.ArrowLeft || keys.KeyA) kart.rotation.y += 0.03 * (speed / maxSpeed);
      if (keys.ArrowRight || keys.KeyD) kart.rotation.y -= 0.03 * (speed / maxSpeed);
      // Move
      kart.translateZ(speed);

      // Camera follow
      const relativeCameraOffset = new THREE.Vector3(0, 5, -10);
      const cameraOffset = relativeCameraOffset.applyMatrix4(kart.matrixWorld);
      camera.position.lerp(cameraOffset, 0.1);
      camera.lookAt(kart.position);

      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>