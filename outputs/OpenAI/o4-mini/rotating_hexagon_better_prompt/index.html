<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rotating Hexagon with Bouncing Balls</title>
  <style>
    /* Reset and full-screen canvas */
    body { margin: 0; overflow: hidden; background: #222; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Simulation variables
    let W, H, R;
    let center = { x: 0, y: 0 };
    let vertices = [];
    let normals = [];
    let balls = [];

    const BALL_COUNT = 20;
    const BALL_RADIUS = 10;
    const ANG_VEL = Math.PI / 6; // 30Â° per second

    // Resize handler: update canvas size and recompute geometry
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      W = canvas.width;
      H = canvas.height;
      center.x = W / 2;
      center.y = H / 2;
      R = Math.min(W, H) * 0.4; // hexagon radius
      computeHexagon();
      initBalls();
    }
    window.addEventListener('resize', resize);
    resize();

    // Compute hexagon vertices and inward normals
    function computeHexagon() {
      vertices = [];
      normals = [];

      // Vertices in hexagon frame
      for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        vertices.push({
          x: R * Math.cos(angle),
          y: R * Math.sin(angle)
        });
      }

      // Edge normals
      for (let i = 0; i < 6; i++) {
        const v0 = vertices[i];
        const v1 = vertices[(i + 1) % 6];
        const dx = v1.x - v0.x;
        const dy = v1.y - v0.y;
        // Perpendicular vector
        let nx = dy;
        let ny = -dx;
        // Normalize
        const len = Math.hypot(nx, ny);
        nx /= len;
        ny /= len;
        // Ensure the normal points inward
        const mx = (v0.x + v1.x) / 2;
        const my = (v0.y + v1.y) / 2;
        // If midpoint dot normal is negative, flip
        if (mx * nx + my * ny < 0) {
          nx = -nx;
          ny = -ny;
        }
        const d = nx * v0.x + ny * v0.y;
        normals.push({ nx, ny, d });
      }
    }

    // Initialize balls randomly inside the hexagon
    function initBalls() {
      balls = [];
      const apothem = R * Math.cos(Math.PI / 6) - BALL_RADIUS;
      for (let i = 0; i < BALL_COUNT; i++) {
        // Position
        const ang = Math.random() * 2 * Math.PI;
        const rad = Math.sqrt(Math.random()) * apothem;
        const x = rad * Math.cos(ang);
        const y = rad * Math.sin(ang);
        // Velocity
        const speed = 80 + Math.random() * 120;
        const vang = Math.random() * 2 * Math.PI;
        const vx = speed * Math.cos(vang);
        const vy = speed * Math.sin(vang);
        balls.push({ x, y, vx, vy });
      }
    }

    // Animation loop
    let lastTime = null;
    let theta = 0;

    function animate(ts) {
      if (lastTime === null) lastTime = ts;
      const dt = (ts - lastTime) / 1000;
      lastTime = ts;

      updatePhysics(dt);
      render();
      requestAnimationFrame(animate);
    }

    // Update positions and handle collisions
    function updatePhysics(dt) {
      for (const b of balls) {
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        // Check against each hexagon edge
        for (const e of normals) {
          const dist = e.nx * b.x + e.ny * b.y;
          if (dist + BALL_RADIUS > e.d) {
            // If moving outward, reflect
            const vDot = b.vx * e.nx + b.vy * e.ny;
            if (vDot > 0) {
              b.vx -= 2 * vDot * e.nx;
              b.vy -= 2 * vDot * e.ny;
            }
            // Push back inside
            const overlap = dist + BALL_RADIUS - e.d;
            b.x -= overlap * e.nx;
            b.y -= overlap * e.ny;
          }
        }
      }
      theta += ANG_VEL * dt;
    }

    // Draw hexagon and balls
    function render() {
      ctx.clearRect(0, 0, W, H);
      ctx.save();
      // Move to center and rotate
      ctx.translate(center.x, center.y);
      ctx.rotate(theta);

      // Hexagon outline
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      vertices.forEach((v, i) => {
        if (i === 0) ctx.moveTo(v.x, v.y);
        else ctx.lineTo(v.x, v.y);
      });
      ctx.closePath();
      ctx.stroke();

      // Balls
      ctx.fillStyle = '#ff6';
      for (const b of balls) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_RADIUS, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.restore();
    }

    // Start
    requestAnimationFrame(animate);
  </script>
</body>
</html>