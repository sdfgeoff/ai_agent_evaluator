<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rotating Hexagon with Bouncing Balls</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #111; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // Get canvas and context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Resize canvas to fill window
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      center.x = canvas.width / 2;
      center.y = canvas.height / 2;
    }
    window.addEventListener('resize', resize);

    // Center of hexagon
    const center = { x: 0, y: 0 };
    resize();

    // Hexagon parameters
    const hexRadius = Math.min(canvas.width, canvas.height) * 0.4;
    const baseVertices = [];
    for (let i = 0; i < 6; i++) {
      const a = (i / 6) * Math.PI * 2;
      baseVertices.push({ x: Math.cos(a) * hexRadius, y: Math.sin(a) * hexRadius });
    }

    // Balls
    const ballCount = 30;
    const balls = [];
    const ballRadius = 8;

    function randomIn(min, max) { return min + Math.random() * (max - min); }

    // Ray-casting test for point in polygon
    function pointInPoly(pt, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
          (pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function initBalls() {
      balls.length = 0;
      // need initial rotated hexagon as polygon for spawn
      const poly = baseVertices.map(v => ({ x: v.x + center.x, y: v.y + center.y }));
      while (balls.length < ballCount) {
        const x = randomIn(center.x - hexRadius + ballRadius, center.x + hexRadius - ballRadius);
        const y = randomIn(center.y - hexRadius + ballRadius, center.y + hexRadius - ballRadius);
        if (!pointInPoly({ x, y }, poly)) continue;
        const speed = 1 + Math.random() * 1.5;
        const theta = Math.random() * Math.PI * 2;
        balls.push({ x, y, vx: Math.cos(theta) * speed, vy: Math.sin(theta) * speed });
      }
    }

    initBalls();

    let angle = 0;
    const rotSpeed = 0.005; // radians per frame

    // Draw and update
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      angle += rotSpeed;

      // Compute rotated polygon vertices
      const poly = baseVertices.map(v => {
        const x = v.x * Math.cos(angle) - v.y * Math.sin(angle) + center.x;
        const y = v.x * Math.sin(angle) + v.y * Math.cos(angle) + center.y;
        return { x, y };
      });

      // Draw hexagon
      ctx.strokeStyle = '#0f9';
      ctx.lineWidth = 4;
      ctx.beginPath();
      poly.forEach((p, i) => (i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)));
      ctx.closePath();
      ctx.stroke();

      // Update balls
      balls.forEach(ball => {
        // Move
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Check collision with each edge
        for (let i = 0; i < poly.length; i++) {
          const A = poly[i];
          const B = poly[(i + 1) % poly.length];
          // Edge vector
          const ex = B.x - A.x;
          const ey = B.y - A.y;
          // Normal (perp unit)
          const len = Math.hypot(ex, ey);
          const nx = ey / len;
          const ny = -ex / len;
          // Distance from ball to edge (signed)
          const dist = (ball.x - A.x) * nx + (ball.y - A.y) * ny;
          if (dist > ballRadius) continue;
          // Project ball center onto edge line
          const projLen = ((ball.x - A.x) * ex + (ball.y - A.y) * ey) / (len * len);
          if (projLen < 0 || projLen > 1) continue;
          // Reflect velocity
          const vn = ball.vx * nx + ball.vy * ny;
          ball.vx -= 2 * vn * nx;
          ball.vy -= 2 * vn * ny;
          // Push ball out
          ball.x += (ballRadius - dist) * nx;
          ball.y += (ballRadius - dist) * ny;
        }

        // Draw ball
        ctx.fillStyle = '#f39';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
        ctx.fill();
      });

      requestAnimationFrame(animate);
    }

    // Kick off animation
    requestAnimationFrame(animate);
  </script>
</body>
</html>