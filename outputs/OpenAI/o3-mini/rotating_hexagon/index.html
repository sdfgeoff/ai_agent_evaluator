<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rotating Hexagon with Bouncing Balls</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background: #222; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Resize canvas to full window
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Hexagon parameters (in local coordinate system with origin at center)
    const hexRadius = 200;
    const hexagon = [];
    const sides = 6;

    // Using a static hexagon (non rotated), we'll rotate the entire scene later.
    // We'll set the vertices for the hexagon.
    for (let i = 0; i < sides; i++) {
      // angle for vertex in radians. Starting from 0.
      const angle = i * Math.PI / 3;
      const x = hexRadius * Math.cos(angle);
      const y = hexRadius * Math.sin(angle);
      hexagon.push({x, y});
    }

    // Utility function: check if a point (x,y) is inside a polygon
    // Using ray-casting algorithm
    function pointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi + 0.00001) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Ball class
    class Ball {
      constructor(x, y, vx, vy, r, color) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.r = r;
        this.color = color;
      }
      
      update() {
        // Update position
        let newX = this.x + this.vx;
        let newY = this.y + this.vy;
        
        // If new position is outside the hexagon, reverse velocity
        if (!pointInPolygon(newX, newY, hexagon)) {
          // A simple way: reverse the velocity to simulate bounce
          this.vx = -this.vx;
          this.vy = -this.vy;
          newX = this.x + this.vx;
          newY = this.y + this.vy;
          // In case still out, we could clamp but this simple approach is fine for now.
          if (!pointInPolygon(newX, newY, hexagon)) {
            // If still outside, just keep in bounds by snapping
            newX = Math.max(Math.min(newX, hexRadius - this.r), -hexRadius + this.r);
            newY = Math.max(Math.min(newY, hexRadius - this.r), -hexRadius + this.r);
          }
        }

        this.x = newX;
        this.y = newY;
      }
      
      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }

    // Generate random balls inside the hexagon
    const balls = [];
    const ballCount = 8;
    const colors = ['#ff6666', '#66ff66', '#6666ff', '#ffcc66', '#66ffcc', '#cc66ff'];

    function randomInRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    for (let i = 0; i < ballCount; i++) {
      let x, y;
      // Keep generating until the point is inside the hexagon
      do {
        x = randomInRange(-hexRadius, hexRadius);
        y = randomInRange(-hexRadius, hexRadius);
      } while (!pointInPolygon(x, y, hexagon));
      const vx = randomInRange(-3, 3);
      const vy = randomInRange(-3, 3);
      const r = 8;
      const color = colors[i % colors.length];
      balls.push(new Ball(x, y, vx, vy, r, color));
    }

    let rotationAngle = 0;

    function drawHexagon(ctx) {
      ctx.beginPath();
      ctx.moveTo(hexagon[0].x, hexagon[0].y);
      for (let i = 1; i < hexagon.length; i++) {
        ctx.lineTo(hexagon[i].x, hexagon[i].y);
      }
      ctx.closePath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save the context and translate to center
      ctx.save();
      ctx.translate(canvas.width/2, canvas.height/2);
      
      // Rotate the entire scene
      rotationAngle += 0.01;
      ctx.rotate(rotationAngle);

      // Optionally, clip to the hexagon shape so balls don't appear outside
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(hexagon[0].x, hexagon[0].y);
      for (let i = 1; i < hexagon.length; i++) {
        ctx.lineTo(hexagon[i].x, hexagon[i].y);
      }
      ctx.closePath();
      ctx.clip();

      // Update and draw the balls
      for (let ball of balls) {
        ball.update();
        ball.draw(ctx);
      }
      ctx.restore(); // remove clipping

      // Draw the hexagon boundary
      drawHexagon(ctx);

      ctx.restore(); // restore overall transformation
    }

    animate();
  </script>
</body>
</html>