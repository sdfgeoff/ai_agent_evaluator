<html ><style >
                body { font-family: Arial, sans-serif; background: grey; }
                .block { margin: 5px; padding: 5px; white-space: pre-wrap; background: white; }
                </style><body ><div class="block"><strong >user:</strong> Can you set up a webgl demo for me? I'd like an example of a basic webgl shader. Make sure the output is available in index.html, but you can install any packages necessary.</div><div class="block"><strong >assistant:</strong> 
Sure! Let's create a simple WebGL demo with a basic shader that draws a rotating triangle on a canvas. We will set up everything within an HTML file.

Here are the steps we'll follow:
1. Create an `index.html` file.
2. Add a script to draw a WebGL context.
3. Set up vertex and fragment shaders for rendering a triangle.
4. Implement a function to rotate the triangle over time.

Let's begin with the code:

```html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;WebGL Demo&lt;/title&gt;
    &lt;style&gt;
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id="glCanvas"&gt;&lt;/canvas&gt;
    &lt;script id="vertex-shader" type="x-shader/x-vertex"&gt;
        attribute vec4 a_position;
        uniform mat4 u_rotationMatrix;
        
        void main() {
            gl_Position = u_rotationMatrix * a_position;
        }
    &lt;/script&gt;
    &lt;script id="fragment-shader" type="x-shader/x-fragment"&gt;
        precision mediump float;
        void main() {
            gl_FragColor = vec4(1, 0, 0, 1); // Red
        }
    &lt;/script&gt;
    &lt;script&gt;
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('Unable to initialize WebGL. Your browser may not support it.');
        }

        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        function createProgram(vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }

            gl.useProgram(program);
            return program;
        }

        const program = createProgram(vertexShader, fragmentShader);

        function setBuffersAndAttributes(program) {
            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

            // Set up triangle vertices
            const positions = [
                0.0,  1.0,
               -1.0, -1.0,
                1.0, -1.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        }

        function setUniforms(program) {
            const matrixLocation = gl.getUniformLocation(program, 'u_rotationMatrix');
            // We will update this each frame
            return matrixLocation;
        }

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }

        let rotationMatrix = mat4.create();
        setBuffersAndAttributes(program);
        const matrixLocation = setUniforms(program);

        function render(time) {
            time *= 0.001; // convert to seconds
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.identity(rotationMatrix);
            mat4.rotateY(rotationMatrix, rotationMatrix, time);
            
            gl.uniformMatrix4fv(matrixLocation, false, rotationMatrix);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);

        // Include the gl-matrix library here
        const mat4 = {
            create: function() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },
            identity: function(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            rotateY: function(out, a, rad) {
                let s = Math.sin(rad);
                let c = Math.cos(rad);
                
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

                // Perform axis-specific matrix multiplication
                out[0] = c * a00 + s * a20;
                out[1] = c * a01 + s * a21;
                out[2] = c * a02 + s * a22;
                out[3] = c * a03 + s * a23;
                out[4] =   a10;
                out[5] =   a11;
                out[6] =   a12;
                out[7] =   a13;
                out[8] = -s * a00 + c * a20;
                out[9] = -s * a01 + c * a21;
                out[10] = -s * a02 + c * a22;
                out[11] = -s * a03 + c * a23;

                return out;
            }
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
```

This code sets up a WebGL context and draws a rotating red triangle. The shader is simple: the vertex shader applies a rotation matrix to the vertices, and the fragment shader just outputs a solid color (red in this case).

To run this, save the code above as `index.html` and open it in a web browser. You should see a red rotating triangle on the screen.

This example does not use any external libraries for WebGL, but if you need more advanced features or find that integrating an external library is necessary, let me know!</div><div class="block"><strong >assistant:</strong> </div></body></html>